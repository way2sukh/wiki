## Classes and Interfaces
- ### Item 15: Minimize the accessibility of classes and members
	The rule of thumb is simple: make each class or member as inaccessible as possible.
- ### Item 16: In public classes, use accessor methods, not public fields
	If a class is accessible outside its package, provide accessor methods to preserve the flexibility to change the class’s internal representation. If a public class exposes its data fields, all hope of changing its representation is lost because client code can be distributed far and wide. <br /> 
	However, if a class is package-private or is a private nested class, there is nothing inherently wrong with exposing its data fields—assuming they do an adequate job of describing the abstraction provided by the class.
- ### Item 17: Minimize mutability
	To make a class immutable, follow these five rules:
	1. Don’t provide methods that modify the object’s state (known as mutators).
	2. Ensure that the class can’t be extended. 
	3. Make all fields final. 
	4. Make all fields private.
	5. Ensure exclusive access to any mutable components. <br />
	**Benefits :** 
	- Immutable objects are inherently thread-safe; they require no synchronization.
	- Immutable objects can be shared freely.
	- Not only can you share immutable objects, but they can share their internals.
	- Immutable objects make great building blocks for other objects.
	- Immutable objects provide failure atomicity for free. <br />
	*The major disadvantage of immutable classes is that they require a separate object for each distinct value.*
- ### Item 18: Favor composition over inheritance
	Inheritance is powerful, but it is problematic because it violates encapsulation. It is appropriate only when a genuine subtype relationship exists between the subclass and the superclass. Even then, inheritance may lead to fragility if the subclass is in a different package from the superclass and the superclass is not designed for inheritance. To avoid this fragility, use composition and forwarding instead of inheritance, especially if an appropriate interface to implement a wrapper class exists. Not only are wrapper classes more robust than subclasses, they are also more powerful.
- ### Item 19: Design and document for inheritance or else prohibit it
	Class must document its self-use of overridable methods. For each public or protected method, the documentation must indicate which overridable methods the method invokes, in what sequence, and how the results of each invocation affect subsequent processing. <br />
	A method that invokes overridable methods contains a description of these invocations at the end of its documentation comment. The description is in a special section of the specification, labeled “Implementation Requirements,” which is generated by the Javadoc tag @implSpec. This section describes the inner workings of the method.
- ### Item 20: Prefer interfaces to abstract classes
	- Existing classes can easily be retrofitted to implement a new interface. Existing classes cannot, in general, be retrofitted to extend a new abstract class. If you want to have two classes extend the same abstract class, you have to place it high up in the type hierarchy where it is an ancestor of both classes.
	- Interfaces are ideal for defining mixins. Loosely speaking, a mixin is a type that a class can implement in addition to its “primary type,” to declare that it provides some optional behavior. 
	- Interfaces allow for the construction of nonhierarchical type frameworks. 
	- Interfaces enable safe, powerful functionality enhancements via the wrapper class idiom. If you use abstract classes to define types, you leave the programmer who wants to add functionality with no alternative but inheritance. 
- ### Item 21: Design interfaces for posterity
	- It is not always possible to write a default method that maintains all invariants of every conceivable implementation.
	- In the presence of default methods, existing implementations of an interface may compile without error or warning but fail at runtime.
- ### Item 22: Use interfaces only to define types
	The constant interface pattern is a poor use of interfaces. If you want to export constants, there are several reasonable choices :
	- If the constants are strongly tied to an existing class or interface, you should add them to the class or interface. 
	- If the constants are best viewed as members of an enumerated type, you should export them with an enum type.
	- Otherwise, export the constants with a noninstantiable utility class.
- ### Item 23: Prefer class hierarchies to tagged classes
	Tagged classes are verbose, error-prone, and inefficient. Rather transform a tagged class into a class hierarchy.
- ### Item 24: Favor static member classes over nonstatic
	A nested class is a class defined within another class. A nested class should exist only to serve its enclosing class. If a nested class would be useful in some other context, then it should be a top-level class. There are four kinds of nested classes: static member classes, nonstatic member classes, anonymous classes, and local classes. All but the first kind are known as inner classes. <br />
	If you declare a member class that does not require access to an enclosing instance, always put the static modifier in its declaration, making it a static rather than a nonstatic member class. If you omit this modifier, each instance will have a hidden extraneous reference to its enclosing instance, storing this reference takes time and space. <br />
	If a nested class needs to be visible outside of a single method or is too long to fit comfortably inside a method, use a member class. If each instance of a member class needs a reference to its enclosing instance, make it nonstatic; otherwise, make it static. Assuming the class belongs inside a method, if you need to create instances from only one location and there is a preexisting type that characterizes the class, make it an anonymous class; otherwise, make it a local class.
- ### Item 25: Limit source files to a single top-level class
	Never put multiple top-level classes or interfaces in a single source file. Following this rule guarantees that you can’t have multiple definitions for a single class at compile time. This in turn guarantees that the class files generated by compilation, and the behavior of the resulting program, are independent of the order in which the source files are passed to the compiler.